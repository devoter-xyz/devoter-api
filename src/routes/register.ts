import type { FastifyInstance, FastifyRequest, RouteGenericInterface } from "fastify";
import { verifyWalletSignature } from "../middleware/auth.js";
import { rateLimitConfigs } from "../middleware/rateLimit.js";
import * as Type from "@sinclair/typebox";
import {
  ApiError,
  asyncHandler,
  HttpStatusCode,
} from "../utils/errorHandler.js";
import { prisma } from "../lib/prisma.js";
import { validateRegisterPayload } from "../utils/validation.js";

// Define the expected request body type for clarity and reusability
/**
 * @typedef {object} RegisterRequestBody
 * @property {string} walletAddress - The blockchain wallet address of the user.
 * @property {string} message - The message signed by the wallet to prove ownership.
 * @property {string} signature - The signature generated by the wallet.
 */
type RegisterRequestBody = {
  walletAddress: string;
  message: string;
  signature: string;
};

interface RegisterRoute extends RouteGenericInterface {
  Body: RegisterRequestBody;
}

export default async function registerRoute(fastify: FastifyInstance) {
  // POST /register - Register a new user with wallet authentication
  fastify.post<RegisterRoute>("/register", {
    schema: {
      body: Type.Object({
        walletAddress: Type.RegExp(/^0x[a-fA-F0-9]{40}$/, {
          description: "The blockchain wallet address of the user.",
        }),
        message: Type.String({ minLength: 1, maxLength: 1000, description: "The message signed by the wallet to prove ownership." }),
        signature: Type.RegExp(/^0x[a-fA-F0-9]{130}$/, { description: "The signature generated by the wallet." }),
      }),
      response: {
        200: Type.Object({
          success: Type.Literal(true),
          userId: Type.String(),
          message: Type.String(),
        }),
        201: Type.Object({
          success: Type.Literal(true),
          userId: Type.String(),
          message: Type.String(),
        }),
        500: Type.Object({
          success: Type.Literal(false),
          error: Type.String(),
        }),
        // Consistent error response for validation failures (e.g., 400 Bad Request)
        400: Type.Object({
          statusCode: Type.Number(),
          message: Type.String(),
          code: Type.String(),
          details: Type.Optional(Type.Object({})),
        }),
      },
    },
    config: {
      rateLimit: rateLimitConfigs.registration,
    },
    preHandler: verifyWalletSignature,
    handler: asyncHandler<RegisterRoute>(async (request, reply) => {


      if ('email' in request.body || 'password' in request.body) {
        return reply.code(400).send({
          statusCode: 400,
          message: 'Traditional authentication not supported',
          code: 'TRADITIONAL_AUTH_NOT_SUPPORTED',
        });
      }

      const { walletAddress } = request.body;
      // Normalize input: trim and lowercase the wallet address
      const normalizedWalletAddress = walletAddress.trim().toLowerCase();



      // Check if user already exists
      const existingUser = await prisma.apiUser.findUnique({
        where: { walletAddress: normalizedWalletAddress },
      });

      if (existingUser) {
        return reply.status(HttpStatusCode.OK).send({
          success: true,
          userId: existingUser.id,
          message: "User already registered",
        });
      }

      try {
        // Create new user

        const newUser = await prisma.apiUser.create({
          data: {
            walletAddress: normalizedWalletAddress,
          },
        });

        return reply.status(HttpStatusCode.CREATED).send({
          success: true,
          userId: newUser.id,
          message: "User registered successfully",
        });
      } catch (error) {
        // This will be caught by asyncHandler

        // Handle race condition where user was created between our check and create
        // This can happen if two requests for the same wallet address are processed simultaneously.
        if ((error as any)?.code === "P2002") {
          const existingUser = await prisma.apiUser.findUnique({
            where: { walletAddress: normalizedWalletAddress },
          });

          if (existingUser) {
            return reply.status(HttpStatusCode.OK).send({
              success: true,
              userId: existingUser.id,
              message: "User already registered",
            });
          }
        }

        // Re-throw to be caught by asyncHandler
        throw error;
      }
    }),
  });
}
