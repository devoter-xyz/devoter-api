import type { FastifyInstance } from "fastify";
import { verifyWalletSignature } from "../middleware/auth.js";
import { rateLimitConfigs } from "../middleware/rateLimit.js";
import * as Type from "@sinclair/typebox";
import {
  ApiError,
  asyncHandler,
  HttpStatusCode,
} from "../utils/errorHandler.js";
import { prisma } from "../lib/prisma.js";

// Define the expected request body type for clarity and reusability
/**
 * @typedef {object} RegisterRequestBody
 * @property {string} walletAddress - The blockchain wallet address of the user.
 * @property {string} message - The message signed by the wallet to prove ownership.
 * @property {string} signature - The signature generated by the wallet.
 */
type RegisterRequestBody = {
  walletAddress: string;
  message: string;
  signature: string;
};

export default async function registerRoute(fastify: FastifyInstance) {
  // POST /register - Register a new user with wallet authentication
  fastify.post("/register", {
    schema: {
      body: Type.Object({
        walletAddress: Type.RegExp(/^0x[a-fA-F0-9]{40}$/, {
          transform: (value: string) => value.trim().toLowerCase(),
          description: "The blockchain wallet address of the user.",
        }),
        message: Type.String({ minLength: 1, maxLength: 1000, description: "The message signed by the wallet to prove ownership." }),
        signature: Type.RegExp(/^0x[a-fA-F0-9]{130}$/, { description: "The signature generated by the wallet." }),
        // Optional password for traditional login methods, with length constraints
        // TODO: Traditional authentication support (email/password) is intentionally omitted.
        // If re-introduced, it must include secure storage and best practices:
        // - bcrypt/argon2 hashing
        // - complexity checks
        // - breach-list checks
        // - uniqueness checks
        // - HTTPS-only transport
        // - etc.
        // password: Type.Optional(Type.String({
        //   minLength: 8,
        //   maxLength: 64,
        //   description: "Optional: The user's password for traditional login methods. Must be between 8 and 64 characters.",
        // })),
      }),
      response: {
        200: Type.Object({
          success: Type.Literal(true),
          userId: Type.String(),
          message: Type.String(),
        }),
        201: Type.Object({
          success: Type.Literal(true),
          userId: Type.String(),
          message: Type.String(),
        }),
        500: Type.Object({
          success: Type.Literal(false),
          error: Type.String(),
        }),
        // Consistent error response for validation failures (e.g., 400 Bad Request)
        400: Type.Object({
          statusCode: Type.Number(),
          message: Type.String(),
          code: Type.String(),
          details: Type.Optional(Type.Object({})),
        }),
      },
    },
    config: {
      rateLimit: rateLimitConfigs.registration,
    },
    preHandler: verifyWalletSignature,
    handler: asyncHandler(async (request, reply) => {
      if ('email' in request.body || 'password' in request.body) {
        return reply.code(400).send({
          statusCode: 400,
          message: 'Traditional authentication not supported',
          code: 'TRADITIONAL_AUTH_NOT_SUPPORTED',
        });
      }

      const { walletAddress } = request.body as RegisterRequestBody;
      // Normalize input: trim and lowercase the wallet address
      const normalizedWalletAddress = walletAddress.trim().toLowerCase();



      // Check if user already exists
      const existingUser = await prisma.apiUser.findUnique({
        where: { walletAddress: normalizedWalletAddress },
      });

      if (existingUser) {
        return reply.status(HttpStatusCode.OK).send({
          success: true,
          userId: existingUser.id,
          message: "User already registered",
        });
      }

      try {
        // Create new user

        const newUser = await prisma.apiUser.create({
          data: {
            walletAddress: normalizedWalletAddress,
          },
        });

        return reply.status(HttpStatusCode.CREATED).send({
          success: true,
          userId: newUser.id,
          message: "User registered successfully",
        });
      } catch (error) {
        // This will be caught by asyncHandler

        // Handle race condition where user was created between our check and create
        // This can happen if two requests for the same wallet address are processed simultaneously.
        if ((error as any)?.code === "P2002") {
          const existingUser = await prisma.apiUser.findUnique({
            where: { walletAddress: normalizedWalletAddress },
          });

          if (existingUser) {
            return reply.status(HttpStatusCode.OK).send({
              success: true,
              userId: existingUser.id,
              message: "User already registered",
            });
          }
        }

        // Re-throw to be caught by asyncHandler
        throw error;
      }
    }),
  });
}
