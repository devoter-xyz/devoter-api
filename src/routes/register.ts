import type { FastifyInstance } from "fastify";
import { verifyWalletSignature } from "../middleware/auth.js";
import { rateLimitConfigs } from "../middleware/rateLimit.js";
import * as Type from "@sinclair/typebox";
import {
  ApiError,
  asyncHandler,
  HttpStatusCode,
} from "../utils/errorHandler.js";
import { prisma } from "../lib/prisma.js";

// Define the expected request body type for clarity and reusability
/**
 * @typedef {object} RegisterRequestBody
 * @property {string} walletAddress - The blockchain wallet address of the user.
 * @property {string} message - The message signed by the wallet to prove ownership.
 * @property {string} signature - The signature generated by the wallet.
 * @property {string} [email] - Optional: The user's email address for traditional login methods.
 * @property {string} [password] - Optional: The user's password for traditional login methods.
 */
type RegisterRequestBody = {
  walletAddress: string;
  message: string;
  signature: string;
  email?: string;
  password?: string;
};

export default async function registerRoute(fastify: FastifyInstance) {
  // POST /register - Register a new user with wallet authentication
  fastify.post("/register", {
    schema: {
      body: Type.Object({
        walletAddress: Type.RegExp(/^0x[a-fA-F0-9]{40}$/, {
          transform: (value: string) => value.trim().toLowerCase(),
          description: "The blockchain wallet address of the user.",
        }),
        message: Type.String({ minLength: 1, maxLength: 1000, description: "The message signed by the wallet to prove ownership." }),
        signature: Type.RegExp(/^0x[a-fA-F0-9]{130}$/, { description: "The signature generated by the wallet." }),
        // Optional email for traditional login methods, with format validation
        email: Type.Optional(Type.String({
          format: "email",
          description: "Optional: The user's email address for traditional login methods.",
        })),
        // Optional password for traditional login methods, with length constraints
        password: Type.Optional(Type.String({
          minLength: 8,
          maxLength: 64,
          description: "Optional: The user's password for traditional login methods. Must be between 8 and 64 characters.",
        })),
      }),
      response: {
        200: Type.Object({
          success: Type.Literal(true),
          userId: Type.String(),
          message: Type.String(),
        }),
        201: Type.Object({
          success: Type.Literal(true),
          userId: Type.String(),
          message: Type.String(),
        }),
        500: Type.Object({
          success: Type.Literal(false),
          error: Type.String(),
        }),
        // Consistent error response for validation failures (e.g., 400 Bad Request)
        400: Type.Object({
          success: Type.Literal(false),
          error: Type.String(),
          issues: Type.Optional(Type.Array(Type.Object({
            path: Type.Array(Type.String()),
            message: Type.String(),
          }))),
        }),
      },
    },
    config: {
      rateLimit: rateLimitConfigs.registration,
    },
    preHandler: verifyWalletSignature,
    handler: asyncHandler(async (request, reply) => {

      const { walletAddress, email, password } = request.body as RegisterRequestBody;
      // Normalize input: trim and lowercase the wallet address
      const normalizedWalletAddress = walletAddress.trim().toLowerCase();

      // If email or password are provided, they are currently validated by the schema.
      // Further backend logic (e.g., storing email/password, hashing password) would be needed
      // to fully integrate traditional email/password registration. This is outside the scope
      // of this route file and would require database schema changes.

      // Check if user already exists
      const existingUser = await prisma.apiUser.findUnique({
        where: { walletAddress: normalizedWalletAddress },
      });

      if (existingUser) {
        return reply.status(HttpStatusCode.OK).send({
          success: true,
          userId: existingUser.id,
          message: "User already registered",
        });
      }

      try {
        // Create new user

        const newUser = await prisma.apiUser.create({
          data: {
            walletAddress: normalizedWalletAddress,
          },
        });

        return reply.status(HttpStatusCode.CREATED).send({
          success: true,
          userId: newUser.id,
          message: "User registered successfully",
        });
      } catch (error) {
        // This will be caught by asyncHandler

        // Handle race condition where user was created between our check and create
        // This can happen if two requests for the same wallet address are processed simultaneously.
        if ((error as any)?.code === "P2002") {
          const existingUser = await prisma.apiUser.findUnique({
            where: { walletAddress: normalizedWalletAddress },
          });

          if (existingUser) {
            return reply.status(HttpStatusCode.OK).send({
              success: true,
              userId: existingUser.id,
              message: "User already registered",
            });
          }
        }

        // Re-throw to be caught by asyncHandler
        throw error;
      }
    }),
  });
}
