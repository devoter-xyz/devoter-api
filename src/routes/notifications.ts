import type { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { verifySignatureWithTimestamp, isValidEthereumAddress } from '../utils/verifySignature';
import { replayProtectionCache } from '../lib/replayProtectionCache';

const REPLAY_PROTECTION_TTL = 330; // 5.5 minutes, slightly longer than typical 5-minute timestamp window

interface Notification {
  id: string;
  user: string;
  message: string;
  createdAt: Date;
}

interface NotificationStore {
  push: (notification: Notification) => void;
  getAll: () => Notification[];
  clear: () => void;
}

// TODO: This module-level in-memory notifications array is unsafe for production.
// It suffers from per-worker copies, unbounded growth, and data loss on restart.
// Before deployment, replace this with a persistent store (e.g., PostgreSQL, Redis).
// Implement a bounded retention strategy (e.g., max size, TTL) and pagination/limit support.
// Refactor the code to use an async persistence layer (abstracted repository/service)
// instead of directly accessing this mutable module-level state, ensuring clustered
// workers share data and memory usage is controlled.
const notifications: Notification[] = [];

const defaultNotificationStore: NotificationStore = {
  push: (notification) => notifications.push(notification),
  getAll: () => notifications,
  clear: () => { notifications.length = 0; }
};

interface NotificationsRoutesOptions extends FastifyPluginOptions {
  notificationStore?: NotificationStore;
}

async function notificationsRoutes(fastify: FastifyInstance, options: NotificationsRoutesOptions) {
  const store = options.notificationStore || defaultNotificationStore;

  // GET /notifications - fetch all notifications with pagination
  fastify.get('/notifications', {
    schema: {
      querystring: {
        type: 'object',
        properties: {
          limit: { type: 'integer', minimum: 1, default: 10 },
          offset: { type: 'integer', minimum: 0, default: 0 },
        },
      },
    },
  }, async (request, reply) => {
    const { limit, offset } = request.query as { limit: number; offset: number };

    const allNotifications = store.getAll();
    const paginatedNotifications = allNotifications.slice(offset, offset + limit);

    return {
      notifications: paginatedNotifications,
      totalCount: allNotifications.length,
      limit,
      offset,
    };
  });

  // POST /notifications - create a new notification
  fastify.post('/notifications', {
    schema: {
      body: {
        type: 'object',
        required: ['user', 'message', 'signedMessage', 'signature'],
        properties: {
          user: { type: 'string', description: 'Wallet address of the user' },
          message: { type: 'string', description: 'Content of the notification' },
          signedMessage: { type: 'string', description: 'The original message that was signed by the user' },
          signature: { type: 'string', description: 'The signature generated by the user\'s wallet' },
        },
      },
    },
  }, async (request, reply) => {
    const { user, message, signedMessage, signature } = request.body as {
      user: string;
      message: string;
      signedMessage: string;
      signature: string;
    };


    // Validate Ethereum address format
    if (!isValidEthereumAddress(user)) {
      reply.status(400);
      return { error: 'Invalid Ethereum address format for user.' };
    }

    // Verify the signature with timestamp to prevent replay attacks
    const { isValid, error } = verifySignatureWithTimestamp(signedMessage, signature, user);

    if (!isValid) {
      request.log.error({ user, signedMessage, error }, 'Signature verification failed');
      reply.status(401);
      return { error: "Unauthorized: Invalid signature or expired message." };
    }

    // Atomically record the signature to prevent replay attacks
    if (!replayProtectionCache.set(signature, REPLAY_PROTECTION_TTL)) {
      request.log.warn({ user, signedMessage, signature }, 'Replay attack detected: signature already used (atomic set failed).');
      reply.status(401);
      return { error: "Unauthorized: Message has already been processed." };
    }

    const newNotification: Notification = {
      id: Math.random().toString(36).substr(2, 9),
      user,
      message,
      createdAt: new Date(),
    };
    store.push(newNotification);
    reply.status(201);
    return newNotification;
  });
}

export default notificationsRoutes;
