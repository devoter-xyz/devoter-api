import { describe, it, expect } from 'vitest';
import { Static, Type } from '@sinclair/typebox';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';

// Schemas from src/routes/register.ts
const RegisterRequestBodySchema = Type.Object({
  walletAddress: Type.String({ pattern: '^0x[a-fA-F0-9]{40}$',
    description: "The blockchain wallet address of the user.",
  }),
  message: Type.String({ minLength: 1, maxLength: 1000, description: "The message signed by the wallet to prove ownership." }),
  signature: Type.String({ pattern: '^0x[a-fA-F0-9]{130}$', description: "The signature generated by the wallet." }),
});

const RegisterResponse200Schema = Type.Object({
  success: Type.Literal(true),
  userId: Type.String(),
  message: Type.String(),
});

const RegisterResponse201Schema = Type.Object({
  success: Type.Literal(true),
  userId: Type.String(),
  message: Type.String(),
});

const ErrorResponseSchema = Type.Object({
  success: Type.Literal(false),
  error: Type.String(),
});

const BadRequestErrorResponseSchema = Type.Object({
  statusCode: Type.Number(),
  message: Type.String(),
  code: Type.String(),
  details: Type.Optional(Type.Object({})),
});

const ajv = new Ajv();
addFormats(ajv);

describe('Register Route Schemas', () => {
  describe('POST /register (Register User)', () => {
    const validateBody = ajv.compile(RegisterRequestBodySchema);
    const validateResponse200 = ajv.compile(RegisterResponse200Schema);
    const validateResponse201 = ajv.compile(RegisterResponse201Schema);
    const validateErrorResponse = ajv.compile(ErrorResponseSchema);
    const validateBadRequestErrorResponse = ajv.compile(BadRequestErrorResponseSchema);

    it('should validate a valid request body', () => {
      const body = {
        walletAddress: '0x' + 'a'.repeat(40),
        message: 'register message',
        signature: '0x' + 'b'.repeat(130),
      };
      expect(validateBody(body)).toBe(true);
    });

    it('should invalidate body with missing walletAddress', () => {
      const body = {
        message: 'register message',
        signature: '0x' + 'b'.repeat(130),
      };
      expect(validateBody(body)).toBe(false);
      expect(validateBody.errors?.[0].message).toBe("must have required property 'walletAddress'");
    });

    it('should invalidate body with invalid walletAddress format', () => {
      const body = {
        walletAddress: '0x' + 'g'.repeat(40), // Invalid hex char
        message: 'register message',
        signature: '0x' + 'b'.repeat(130),
      };
      expect(validateBody(body)).toBe(false);
      expect(validateBody.errors?.[0].message).toBe("must match pattern \"^0x[a-fA-F0-9]{40}$\"");
    });

    it('should invalidate body with message too short', () => {
      const body = {
        walletAddress: '0x' + 'a'.repeat(40),
        message: '',
        signature: '0x' + 'b'.repeat(130),
      };
      expect(validateBody(body)).toBe(false);
      expect(validateBody.errors?.[0].message).toBe("must NOT have fewer than 1 characters");
    });

    it('should invalidate body with message too long', () => {
      const body = {
        walletAddress: '0x' + 'a'.repeat(40),
        message: 'a'.repeat(1001),
        signature: '0x' + 'b'.repeat(130),
      };
      expect(validateBody(body)).toBe(false);
      expect(validateBody.errors?.[0].message).toBe("must NOT have more than 1000 characters");
    });

    it('should invalidate body with invalid signature format', () => {
      const body = {
        walletAddress: '0x' + 'a'.repeat(40),
        message: 'register message',
        signature: '0x' + 'b'.repeat(129), // Too short
      };
      expect(validateBody(body)).toBe(false);
      expect(validateBody.errors?.[0].message).toBe("must match pattern \"^0x[a-fA-F0-9]{130}$\"");
    });

    it('should validate a valid 200 response (user already registered)', () => {
      const response = {
        success: true,
        userId: 'some-uuid',
        message: 'User already registered',
      };
      expect(validateResponse200(response)).toBe(true);
    });

    it('should validate a valid 201 response (user registered successfully)', () => {
      const response = {
        success: true,
        userId: 'some-uuid',
        message: 'User registered successfully',
      };
      expect(validateResponse201(response)).toBe(true);
    });

    it('should invalidate 201 response with missing userId', () => {
      const response = {
        success: true,
        message: 'User registered successfully',
      };
      expect(validateResponse201(response)).toBe(false);
      expect(validateResponse201.errors?.[0].message).toBe("must have required property 'userId'");
    });

    it('should validate a valid 500 error response', () => {
      const response = {
        success: false,
        error: 'Internal Server Error',
      };
      expect(validateErrorResponse(response)).toBe(true);
    });

    it('should validate a valid 400 bad request error response', () => {
      const response = {
        statusCode: 400,
        message: 'Traditional authentication not supported',
        code: 'TRADITIONAL_AUTH_NOT_SUPPORTED',
      };
      expect(validateBadRequestErrorResponse(response)).toBe(true);
    });
  });
});
