import { describe, it, expect } from 'vitest';
import { Static, Type } from '@sinclair/typebox';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';

// Schemas from src/routes/notifications.ts
const GetNotificationsQueryStringSchema = Type.Object({
  limit: Type.Optional(Type.Number({ minimum: 1, default: 10 })),
  offset: Type.Optional(Type.Number({ minimum: 0, default: 0 })),
});

const GetNotificationsResponse200Schema = Type.Object({
  notifications: Type.Array(
    Type.Object({
      id: Type.String(),
      user: Type.String(),
      message: Type.String(),
      createdAt: Type.String(), // Date objects are serialized to ISO strings
    })
  ),
  totalCount: Type.Number(),
  limit: Type.Number(),
  offset: Type.Number(),
});

const PostNotificationsBodySchema = Type.Object({
  user: Type.String({ description: 'Wallet address of the user' }),
  message: Type.String({ description: 'Content of the notification' }),
  signedMessage: Type.String({ description: 'The original message that was signed by the user' }),
  signature: Type.String({ description: 'The signature generated by the user\'s wallet' }),
});

const PostNotificationsResponse201Schema = Type.Object({
  id: Type.String(),
  user: Type.String(),
  message: Type.String(),
  createdAt: Type.String(),
});

const ErrorResponseSchema = Type.Object({
  error: Type.String(),
});

const ajv = new Ajv();
addFormats(ajv);

describe('Notifications Route Schemas', () => {
  describe('GET /notifications (Fetch Notifications)', () => {
    const validateQueryString = ajv.compile(GetNotificationsQueryStringSchema);
    const validateResponse200 = ajv.compile(GetNotificationsResponse200Schema);

    it('should validate a valid querystring with defaults', () => {
      const query = {};
      expect(validateQueryString(query)).toBe(true);
      expect(query).toEqual({}); // AJV doesn't add defaults to the original object by default
    });

    it('should validate a valid querystring with custom values', () => {
      const query = { limit: 5, offset: 10 };
      expect(validateQueryString(query)).toBe(true);
    });

    it('should invalidate querystring with limit less than 1', () => {
      const query = { limit: 0 };
      expect(validateQueryString(query)).toBe(false);
      expect(validateQueryString.errors?.[0].message).toBe("must be >= 1");
    });

    it('should invalidate querystring with offset less than 0', () => {
      const query = { offset: -1 };
      expect(validateQueryString(query)).toBe(false);
      expect(validateQueryString.errors?.[0].message).toBe("must be >= 0");
    });

    it('should validate a valid 200 response', () => {
      const response = {
        notifications: [
          {
            id: 'notif1',
            user: '0x' + 'a'.repeat(40),
            message: 'Hello world',
            createdAt: new Date().toISOString(),
          },
        ],
        totalCount: 1,
        limit: 10,
        offset: 0,
      };
      expect(validateResponse200(response)).toBe(true);
    });

    it('should invalidate 200 response with missing totalCount', () => {
      const response = {
        notifications: [],
        limit: 10,
        offset: 0,
      };
      expect(validateResponse200(response)).toBe(false);
      expect(validateResponse200.errors?.[0].message).toBe("must have required property 'totalCount'");
    });

    it('should invalidate 200 response with invalid notification createdAt format', () => {
      const response = {
        notifications: [
          {
            id: 'notif1',
            user: '0x' + 'a'.repeat(40),
            message: 'Hello world',
            createdAt: 12345, // Invalid type
          },
        ],
        totalCount: 1,
        limit: 10,
        offset: 0,
      };
      expect(validateResponse200(response)).toBe(false);
      expect(validateResponse200.errors?.[0].message).toBe("must be string");
    });
  });

  describe('POST /notifications (Create Notification)', () => {
    const validateBody = ajv.compile(PostNotificationsBodySchema);
    const validateResponse201 = ajv.compile(PostNotificationsResponse201Schema);
    const validateErrorResponse = ajv.compile(ErrorResponseSchema);

    it('should validate a valid request body', () => {
      const body = {
        user: '0x' + 'b'.repeat(40),
        message: 'New notification',
        signedMessage: 'signed data',
        signature: '0x' + 'c'.repeat(130),
      };
      expect(validateBody(body)).toBe(true);
    });

    it('should invalidate body with missing user', () => {
      const body = {
        message: 'New notification',
        signedMessage: 'signed data',
        signature: '0x' + 'c'.repeat(130),
      };
      expect(validateBody(body)).toBe(false);
      expect(validateBody.errors?.[0].message).toBe("must have required property 'user'");
    });

    it('should validate a valid 201 response', () => {
      const response = {
        id: 'some-id',
        user: '0x' + 'd'.repeat(40),
        message: 'Notification created',
        createdAt: new Date().toISOString(),
      };
      expect(validateResponse201(response)).toBe(true);
    });

    it('should invalidate 201 response with missing id', () => {
      const response = {
        user: '0x' + 'd'.repeat(40),
        message: 'Notification created',
        createdAt: new Date().toISOString(),
      };
      expect(validateResponse201(response)).toBe(false);
      expect(validateResponse201.errors?.[0].message).toBe("must have required property 'id'");
    });

    it('should validate a valid error response', () => {
      const response = {
        error: 'Unauthorized: Invalid signature',
      };
      expect(validateErrorResponse(response)).toBe(true);
    });
  });
});
